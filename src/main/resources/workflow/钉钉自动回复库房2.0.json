{
  "name": "钉钉自动回复库房2.0",
  "nodes": [
    {
      "parameters": {
        "jsCode": "// 从Webhook接收的钉钉消息中提取content（用户输入的指令）\n// const dingtalkMsg = $input.body; // Webhook接收的消息体\nconst userInput = $input.first().json.content// 钉钉消息中的内容（如#查询订单 123）\n// 生成会话ID：用用户ID（确保唯一，区分不同用户的上下文）\nconst sessionId = $input.first().json.sessionId; \n\n// 输出userInput，传递给后续节点（替代原来Chat Trigger的输入）\nreturn {\n  userInput: userInput,\n  // 可选：传递其他字段（如userName/groupName）\n  userName: \"name\",\n  groupName: \"groupname\",\n  sessionId: sessionId\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        16,
        640
      ],
      "id": "69158f2d-c554-420a-8ff0-c7082f38e5ed",
      "name": "get msg from dingtalk"
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $json.session }}",
        "contextWindowLength": 10
      },
      "id": "fd6f707c-222e-40fe-894b-89d0d5ef6751",
      "name": "Window Buffer Memory",
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "position": [
        1072,
        864
      ],
      "typeVersion": 1.2
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "232c4e0a-56d9-45bb-b9e2-d655ae424b89",
              "name": "",
              "value": "{{ $('query table column').item.json.table_name}}",
              "type": "string"
            }
          ]
        },
        "includeOtherFields": true,
        "options": {}
      },
      "id": "0d7682a9-1279-44f0-9ee0-69ac12533ca6",
      "name": "Add table name to output",
      "type": "n8n-nodes-base.set",
      "position": [
        704,
        304
      ],
      "typeVersion": 3.4
    },
    {
      "parameters": {
        "operation": "write",
        "fileName": "./assemblylinetest.json",
        "options": {}
      },
      "id": "1c02aeea-66e0-43fe-aff9-4f1fd201f3fe",
      "name": "Save file locally",
      "type": "n8n-nodes-base.readWriteFile",
      "position": [
        1152,
        304
      ],
      "typeVersion": 1
    },
    {
      "parameters": {
        "operation": "fromJson",
        "options": {}
      },
      "id": "e582f766-be5a-4ae3-817d-03a1692e2a83",
      "name": "Extract data from file",
      "type": "n8n-nodes-base.extractFromFile",
      "position": [
        480,
        640
      ],
      "typeVersion": 1
    },
    {
      "parameters": {},
      "id": "104cb803-0c5d-4881-af0f-87482cdd77f0",
      "name": "When clicking \"Test workflow\"",
      "type": "n8n-nodes-base.manualTrigger",
      "position": [
        32,
        304
      ],
      "typeVersion": 1
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "f78c57d9-df13-43c7-89a7-5387e528107e",
              "name": "chatinput",
              "type": "string",
              "value": "={{ $('Webhook').item.json.body.content }}"
            },
            {
              "id": "e42b39eb-dfbd-48d9-94ed-d658bdd41454",
              "name": "schema",
              "type": "string",
              "value": "={{ $json.data }}"
            },
            {
              "id": "a29c18d1-742d-440c-83fd-ffa025b6e1f5",
              "name": "session",
              "value": "={{ $('Webhook').item.json.body.sessionId }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "id": "30b57037-c72f-4035-8a7b-78bb9df65f72",
      "name": "Combine schema data and chat input",
      "type": "n8n-nodes-base.set",
      "position": [
        704,
        640
      ],
      "executeOnce": true,
      "typeVersion": 3.4
    },
    {
      "parameters": {
        "fileSelector": "./assemblylinetest.json",
        "options": {}
      },
      "id": "a374c960-3b36-4c87-83a7-9842fdbb5651",
      "name": "Load the schema from the local file",
      "type": "n8n-nodes-base.readWriteFile",
      "position": [
        256,
        640
      ],
      "typeVersion": 1
    },
    {
      "parameters": {
        "operation": "toJson",
        "options": {}
      },
      "id": "39a6cdff-6a36-4d64-aebc-49c7c22eb2ee",
      "name": "Convert data to Json",
      "type": "n8n-nodes-base.convertToFile",
      "position": [
        928,
        304
      ],
      "typeVersion": 1.1
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT \n  column_name, \n  data_type, \n  is_nullable, \n  column_default\nFROM information_schema.columns\nWHERE table_name  = '{{ $json.table_name }}'\n  AND table_schema = 'assemblylinetest'\nORDER BY ordinal_position;",
        "options": {}
      },
      "type": "n8n-nodes-base.mySql",
      "typeVersion": 2.5,
      "position": [
        480,
        304
      ],
      "id": "cec4c23a-2db1-4a51-b2e6-b66309c277d4",
      "name": "query table column",
      "credentials": {
        "mySql": {
          "id": "jeuyRGGNFRmxYNor",
          "name": "MySQL account"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT\n\ttable_name\nFROM\n\tinformation_schema. TABLES\nWHERE\n\tTABLE_schema = 'assemblylinetest'\nAND table_name IN (\n\t'final_storeroom_conf',\n\t'final_storeroom_store',\n\t'product_material',\n\t'stock_expired_time',\n\t'stock_log',\n\t'store',\n\t'storeroom'\n)",
        "options": {}
      },
      "type": "n8n-nodes-base.mySql",
      "typeVersion": 2.5,
      "position": [
        256,
        304
      ],
      "id": "dbb9118c-741c-493e-8b80-0718ca1bfe92",
      "name": "query tables name",
      "credentials": {
        "mySql": {
          "id": "jeuyRGGNFRmxYNor",
          "name": "MySQL account"
        }
      }
    },
    {
      "parameters": {
        "options": {
          "maxTokens": 1024
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatDeepSeek",
      "typeVersion": 1,
      "position": [
        880,
        864
      ],
      "id": "838b7bb2-5a4c-4496-9fe8-67bc3fe7d67c",
      "name": "DeepSeek Chat Model",
      "credentials": {
        "deepSeekApi": {
          "id": "bbxetBHK56SfIClw",
          "name": "DeepSeek account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=用户提问{{ $json.chatinput }}",
        "options": {
          "systemMessage": "表结构:{{ $json.schema }}\n一、角色定位\n角色：MySQL DBA 专家，技艺高超、经验丰富的数据库管理员，专注根据用户需求和数据库结构生成精准高效的MySQL查询语句，具备丰富的业务数据设计、优化、查询开发经验，擅长需求分析与精准SQL编写，只输出可执行SQL，无多余解释。\n\n二、核心能力\n精通MySQL SQL查询生成、数据库Schema解读、查询性能优化、聚合分组统计；熟练运用MySQL内置函数、联表查询逻辑，可精准识别业务需求并转化为合规SQL语句；具备数据分析与逻辑推理能力，输出简洁精准的可执行代码。\n\n三、工作规范与流程\n1. 严格秉承MySQL兼容的标准SQL语法，生成的查询语句兼顾准确性与执行性能；\n2. 不做任何超出给定Schema的假设，不编造表结构、字段及关联关系；\n3. 有限交互原则，尽可能根据需求直接推断意图生成SQL，不额外提问；\n4. 数据精简原则，返回满足需求的必要数据即可，不暴露无关敏感信息；\n5. 迭代优化原则，确保生成的SQL语法正确、语义精准，贴合业务需求。\n\n四、数据库表结构与核心字段说明（完整保留）\n1. product_material 产品信息表：记录产品基础信息；\n2. store 库存表：记录库房现存产品信息，position字段为存放位置（下划线分割行列层）；\n3. storeroom 库房表：记录所有库房基础信息；\n4. stock_log 产品出入库日志表（核心）：记录所有产品入库/出库明细，status=1入库、status=2出库；product_material_id关联产品表；name为产品名称；type为产品类型数字编码；common_id为二维码/唯一码；storeroom_id关联库房表；primary_num为入库/出库重量；primary_unit为重量单位；lost_num为出库损耗重量（仅type=3产品使用）；\n5. stock_expired_time 产品过期预警表：common_id关联store表，含expired_time过期时间、notice_max_time预警时间。\n\n五、数据库别名命名规范（完整保留，无删减）\n- 使用表名的缩写或首字母作为别名，避免使用SQL保留字（SET, KEY, INDEX, ORDER, GROUP等）；\n- 推荐别名：st, sl, pm, sr, se_time；\n- 固定缩写规则：product_material → pm；store → s；storeroom → sr；stock_log → sl；stock_expired_time → se_time 或 setime。\n\n六、月份统计强制约束（优先级高于所有规则，完整保留原文）\n1. 当用户提问中包含「上个月、上月、本月、当月」等月份相关词汇时，一律按【完整自然月】进行数据统计，绝对禁止按「天数推算/近30天」统计；\n2. 上月 = 上一个自然月（例如：当前是2026-01，上月就是2025-12-01 至 2025-12-31）；\n3. 本月 = 当前自然月（例如：当前是2026-01，本月就是2026-01-01 至 2026-01-31）；\n4. 所有时间筛选必须使用标准的 DATE_FORMAT 函数生成自然月的开始/结束时间，禁止使用不规范的时间计算语法。\n\n七、SQL生成强制规则【全部必遵，无任何例外，优先级从高到低完整保留所有规则】\n1. 字段别名尽量用中文，type等数字编码字段返回备注里的中文文本，禁止使用 / 、空格等特殊符号；\n2. 只返回纯MySQL SQL语句，不要包含任何说明文字、注释、解释性内容；\n3. 生成的SQL语句必须以 ; 结尾，语法完整无报错；\n4. 严格禁止生成/执行 insert、update、delete、drop 等写操作语句，仅允许生成 select 类查询语句，保护数据库数据安全；\n5. 时间范围强制规范（最高优先级，必须严格执行）：\n   - 用户提问的【上个月】=上一个完整自然月，时间范围固定为上个月1号 00:00 至 上个月最后一天 23:59，SQL写法必须用 DATE_FORMAT(DATE_SUB(CURDATE(), INTERVAL 1 MONTH), '%Y-%m-01') 作为上月开始时间，DATE_FORMAT(CURDATE(), '%Y-%m-01') 作为上月结束时间；\n   - 用户提问的【本月】=当前完整自然月，时间范围固定为本月1号 00:00 至 本月最后一天 23:59，SQL写法必须用 DATE_FORMAT(CURDATE(), '%Y-%m-01') 作为本月开始时间；\n   - 禁止使用 DATE_SUB(CURDATE(), INTERVAL 1 MONTH) 作为上月开始时间、禁止用 CURDATE() 作为上月/本月的结束时间，禁止将月份按「近30天/按天推算」，必须按自然月统计；\n   - 时间字段 create_time 的判断条件，统一使用 >= 开始时间 AND < 结束时间 的闭开区间写法，避免数据漏统计/重复统计；\n6. 时间函数语法规范：\n   - 计算本月1号，正确写法为：DATE_FORMAT(CURDATE(), '%Y-%m-01')，禁止写 CURDATE() - INTERVAL DAY(CURDATE()) - 1 DAY（语法错误）；\n   - 计算上月1号，正确写法为：DATE_FORMAT(DATE_SUB(CURDATE(), INTERVAL 1 MONTH), '%Y-%m-01')；\n7. 如果需要获取库房名称字段，查询stock_log表和store表时，必须关联storeroom表获取；\n8. type字段的取值来源，只能是store表或者stock_log表，禁止从其他表获取；\n9. 联表查询时，必须反复确认联表关联的字段在对应表中真实存在，避免联表字段错误；\n10. 查询保质期相关数据时，主表必须以stock_expired_time表进行联表查询。\n\n八、字段别名+业务逻辑 强制铁则（优先级：最高，必须严格执行，无任何例外，完整保留原文）\n1. 【字段别名强制替换 二次保险】：所有SQL返回的中文别名中，**严禁出现「产量」二字**，无论用户提问是「产量/产能/生产量/出库量/入库量」，全部统一替换为【数量】二字；正确写法：上上个月总入库数量、上个月总出库数量、入库数量环比增长率百分比；错误写法：上上个月总入库产量、上个月总出库产量；替换范围：所有SELECT后的AS中文别名，无任何例外。\n2. 【入库/出库业务逻辑强制规则】：库存日志表 stock_log 中，`status=1` 代表【入库】，`status=2` 代表【出库】，这是唯一判定标准，必须严格区分，禁止混淆/写错；统计「入库数量」：WHERE/CASE条件必须写 `sl.status = 1`；统计「出库数量」：WHERE/CASE条件必须写 `sl.status = 2`；禁止出现「入库/出库条件都写status=1」的低级错误，入库和出库的status条件绝对不能相同。\n3. 【数值字段固定规则】：所有入库/出库的统计数值，统一取表中 `primary_num` 字段求和，无其他数值字段可选。\n4. 【库存/单位 核心字段 强制中文别名（重中之重）】：【所有查询必须遵守】，无任何例外\n   - store表/ stock_log表 中的 `primary_num` 字段，**必须指定中文别名**：库存查询（库房存货/存放情况/当前库存）场景别名固定为【当前数量】；出入库流水场景别名固定为【数量】；\n   - store表/ stock_log表 中的 `primary_unit` 字段，**必须指定中文别名**，固定为【数量单位】，禁止使用原名字段/其他别名；\n   - storeroom表 中的 `storeroom_name` 字段，**必须指定中文别名**，固定为【库房名称】，禁止使用原名字段/其他别名；\n   - product_material/store/stock_log表 中的 `name` 字段，**必须指定中文别名**，固定为【产品名称】，禁止使用原名字段/其他别名；\n   - store表中的 `position` 字段，**必须指定中文别名**，固定为【存放位置】，禁止使用原名字段/其他别名。\n5. 【产品类型 中文翻译 强制规则】：查询结果中如果包含 `type` 字段（产品类型数字编码），**必须用CASE WHEN翻译成中文文本**，禁止返回纯数字编码，翻译规则如下：\n   type=0 → 禁用品, type=1 → 副产品, type=2 → 二维码产品, type=3 → 二分体活牛, type=4 → 箱, type=5 → 四分体, type=6 → 部位肉, type=7 → sn码, type=8 → 没有二维码的成品（物料等）, type=9 → 其他, type=10 → 活牛, type=11 → 标重\n   该字段的中文别名固定为【产品类型】，原数字字段禁止返回。\n6. 月度产品统计强制规则（最高优先级，用户提问「上个月/上月/本月/当月/近两月 产品数量/总数量/汇总/出入库数量/出入库方向/产量对比/数量对比」时必须严格执行）：\n   - 统计维度强制：必须按【产品名称 + 产品类型 + 数量单位 + sr.storeroom_name + sl.status】分组，确保「同产品+同库房+出入库方向」合并为1条数据，不同库房的同产品分开统计，满足库房维度统计需求；禁止按product_material_id、detail_type/详细类型分组，杜绝产品无意义拆分；\n   - 字段返回强制【必返7大核心字段+2个新增必返字段，缺一不可】：必须返回【产品名称、产品类型(中文翻译)、库房名称、数量单位、产品记录数(COUNT(*))、总数量(SUM(sl.primary_num))、出入库方向、统计月份】9个核心字段，字段别名严格按规则执行；\n   - 【统计月份】字段强制规则：格式固定为 `yyyy-MM`，通过 DATE_FORMAT(sl.create_time,'%Y-%m') AS 统计月份 生成，无任何例外；\n   - 【出入库方向】字段强制规则：通过 CASE WHEN sl.status=1 THEN '入库' WHEN sl.status=2 THEN '出库' END AS 出入库方向 生成，禁止返回数字status，无任何例外；\n   - 排序规则强制：按 总数量 DESC 排序，方便查看产品数量排行；\n   - 联表规则强制：查询stock_log表时，必须LEFT JOIN storeroom sr ON sr.id = sl.storeroom_id 获取库房名称，字段别名固定为【库房名称】；\n7. 【双月对比查询强制规则】：当用户提问包含【本月和上月对比/上月和本月数量/近两月/环比】等对比类关键词时，SQL查询需同时返回【本月+上个月】的完整数据，每条数据均携带独立的【统计月份】字段，无需额外筛选，计算器将自动完成对比统计；\n8. 【无效数据过滤】：所有月度统计类SQL，必须过滤掉 SUM(sl.primary_num)=0 的无效数据，通过 HAVING 总数量 > 0 实现，避免0值数据干扰统计结果。\n\n九、补充规则（完整保留）\n1. 所有表示产品重量、产量、库存数的数值，统一描述为「数量」；\n2. 查询stock_log表的时候必须关联storeroom表获取库房名称；\n3. stock_log表type=2代表二维码产品、type=8代表没有二维码的产品；\n4. lost_num字段仅为type=3产品的出库损耗重量，其他产品禁止调用该字段求和。\n\n"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3,
      "position": [
        928,
        640
      ],
      "id": "38cd278a-8466-451b-9780-b95557681768",
      "name": "natural language to sql"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "{{ ($json.output.match(/SELECT[\\s\\S]*?;/i) || [])[0] || \"\" }}",
        "options": {}
      },
      "type": "n8n-nodes-base.mySql",
      "typeVersion": 2.5,
      "position": [
        1280,
        640
      ],
      "id": "e9fe1c1f-3e8c-48a7-8556-fc7a765d7726",
      "name": "sql query",
      "alwaysOutputData": true,
      "credentials": {
        "mySql": {
          "id": "jeuyRGGNFRmxYNor",
          "name": "MySQL account"
        }
      }
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=用户的提问：{{ $('Combine schema data and chat input').first().json.chatinput }}\n这个是查询出来的数据：{{ $('sql query').all().toJsonString() }}\n精准统计数据来源\n{{ JSON.stringify($('万能数据统计计算器').first().json, null, 2) }}\n当前基准时间：{{ $now.toFormat('yyyy-MM-dd') }}",
        "options": {
          "systemMessage": "角色定位：MySQL数据专业总结撰写者，核心职能是将计算器输出的精准数据库统计数据转化为通俗易懂的自然语言报告，具备数据库与自然语言处理双重专业知识，目标受众为从DBA到学生的广泛群体，风格客观、简洁、严谨，无技术壁垒，仅做数据转述不做原创研究，无个人观点。\n\n核心技能：精准提取统计数据的关键信息与业务维度、识别数据类型、验证数据准确性与一致性；可将技术化数据转化为易懂文字，简化复杂数据逻辑但不丢失核心细节；严格遵循规则执行数据展示，不做任何自主计算与合并。\n\n### 所有强制规则【优先级从高到低，全部必严格执行，无任何例外，完整保留】\n1. 【唯一数据铁则】所有统计数据必须以「万能数据统计计算器」JS节点的输出为唯一来源，该节点输出的JSON数据已完成精准统计；严禁自主对数据进行合并、累加、统计、估算、四舍五入，所有数值保留工具返回的原始精度原样展示，无数据的位置统一标注为「--」。\n2. 【时间判定强制规则 (重中之重，新增保质期判定，优先级最高)】\n   - 当前基准时间：以系统传入的【年-月-日 时:分:秒】完整时间为唯一判定标准，所有时间对比均基于此时间，无任何主观判定；\n   - 提问「本月」= 当前基准时间的【年-月】，定义为当月1号到当月月底；\n   - 提问「上个月」= 当前基准时间的上一个【年-月】，定义为上个月1号到上个月月底；\n   - 提问「本月和上个月」= 仅分析【上个月+本月】这两个月份的数据，无第三个月份；\n   - 数据匹配规则：只从提供的统计数据中筛选对应月份的数据，数据里实际有哪个月份就分析哪个月份，不额外追加其他不存在的月份；\n   - 【保质期精准判定规则 核心必遵】当用户提问包含「保质期、过期、预警、效期」任意关键词时，按以下规则精准判定产品状态，优先级最高，无任何例外：\n     ① 已过期产品：产品的【过期时间】 < 当前基准时间 → 该产品为过期状态，必须优先展示；\n     ② 预警中产品：产品的【预警时间】 < 当前基准时间 且 【过期时间】 ≥ 当前基准时间 → 该产品为预警状态，次之展示；\n     ③ 正常保质期产品：产品的【预警时间】 ≥ 当前基准时间 → 该产品为正常状态，最后展示；\n     ④ 时间对比精度：所有过期/预警时间对比，精确到「年月日时分秒」，无任何模糊判定。\n3. 【数据合并与计算强制规则（优先级高于所有规则）】\n   - 数值计算规则：所有统计数值直接读取计算器返回的对应字段，禁止自主核算，例如上月入库总量=计算器返回的上月入库总量字段值；\n   - 产品合并规则：提问无具体库房名称→调用计算器按「产品名称」合并所有库房的同产品数据；提问含具体库房名称→调用计算器按「库房+产品名称」维度展示数据，无需合并跨库房数据；\n   - 数据验证规则：生成报告前必须校验，计算器返回的总入库量=所有产品入库量之和、总出库量=所有产品出库量之和，确保数据一致性；\n   - 合并计算规则：所有数值累加、分组合并均由计算器完成，AI仅读取结果，文本字段取计算器返回的第一条非空值即可。\n4. 【单位隔离核心铁则】所有库存数据已按【单位】完成物理隔离分组（如kg、ml、头、无单位），不同单位的数值绝对禁止进行任何折算、累加、混合统计；生成报告时，必须为每一个存在的单位单独生成产品明细模块，不能遗漏任何单位及有库存的产品，严禁隐藏数据。\n5. 【多数据类型智能解析规则（优先级最高）】\n   - 自动识别2类数据类型，按对应规则展示无需二次计算：①库存明细数据：含groupByUnit单位分组，按单位隔离展示产品/库房库存；②统计汇总数据(月度/年度/环比等)：含statisticData数组，为精准的月份数量对比数据，直接读取展示上月入库数量、上月出库数量、环比增长率即可；\n   - 月度数量对比分析要求：必须展示「环比变化」，包含上月入库/出库数量、上月与上上月的差值、增长率，无增长率则标注无数据；\n   - 数值展示规则：数量数值保留2位小数，百分比增长率原样展示，无数据标注为「--」。\n6. 【保质期提问专属展示规则 (核心新增，完美匹配需求，优先级最高)】\n   - 当用户提问「产品的保质期状况如何、保质期、过期产品、预警产品、效期情况」等相关问题时，**取消所有冗余内容**（如报告摘要、总库存统计、批次唯一码详情），仅做极简精准的分类展示；\n   - 必须按「已过期产品 → 预警中产品 → 正常保质期产品」的优先级排序展示，每一类标题清晰；\n   - 每一条产品信息必须包含：【产品名称 + 库房名称 + 存放位置 + 当前数量（带单位） + 核心时间字段】；\n   - 已过期产品必带：过期时间；预警中产品必带：预警时间+过期时间；正常产品必带：过期时间；\n   - 同产品多库房/多位置的，合并展示产品名称，罗列所有库房+位置+对应数量，简洁清晰。\n\n### 核心约束（无任何放宽，完整保留）\n1. 仅基于提供的计算器数据生成报告，不进行任何原创研究，不注入个人观点与解释；\n2. 避免假设读者具备数据库先验知识，报告内容通俗易懂，重点突出，无冗余细节；\n3. 禁止返回数据库表结构、表字段名、SQL语句等技术内容给用户；\n4. 仅对数据进行一次分析总结，不重复输出相同内容；\n5. 若计算器返回无数据，仅回复「未找到相关数据，请咨询其他问题」，且保持markdown格式。\n\n### 存放位置展示规则\n回复用户时，必须详细体现「具体产品在具体哪个库房的哪个具体位置」，位置信息完整展示不简化。\n\n### Markdown格式强制要求（严格遵守，缺一不可，完整保留）\n# 一级标题\n## 二级标题\n### 三级标题\n**加粗内容**\n*斜体内容*\n> 引用总结内容\n- 无序列表项\n1. 有序列表项\n禁止使用图片、链接、特殊符号，纯文本分析即可。\n\n### 工作流程（完整执行，无删减）\n1. 分析用户提问，确定所需的统计维度（产品/库房/时间）与展示需求；\n2. 读取计算器返回的精准统计数据，解析baseInfo、globalTotal、groupByProduct、groupByWarehouse等字段；\n3. 按上述所有规则提取数据并整理，生成符合markdown格式的报告；\n4. 验证数据一致性，确保无计算错误；\n5. 输出最终报告，严格遵守所有格式与约束要求"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3,
      "position": [
        1792,
        640
      ],
      "id": "c60addb3-10e2-4b76-8b3c-2d2e4018ed49",
      "name": "sql to natural language",
      "executeOnce": true
    },
    {
      "parameters": {
        "options": {
          "maxTokens": 2048
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatDeepSeek",
      "typeVersion": 1,
      "position": [
        1728,
        880
      ],
      "id": "c730a734-b1c1-4d62-a009-5011b3df783c",
      "name": "自然语言chat",
      "credentials": {
        "deepSeekApi": {
          "id": "bbxetBHK56SfIClw",
          "name": "DeepSeek account"
        }
      }
    },
    {
      "parameters": {
        "content": "## 只需运行此部分一次 \n\n* 从托管于本地 PostgreSQL 的数据库中加载所有表的列表\n* 提取每个表的数据库结构并添加表名\n* 将结构转换为二进制 JSON 格式\n* 将结构保存到本地的 `./sales_postgresql.json` 文件中\n\n***现在你可以使用聊天来“对”你的数据说话啦！*** 🎉\n",
        "height": 466,
        "width": 1385,
        "color": 3
      },
      "id": "9ecb3545-8e62-4b52-9687-822f8306beac",
      "name": "Sticky Note",
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        0,
        0
      ],
      "typeVersion": 1
    },
    {
      "parameters": {
        "jsCode": "// 获取前一步AI Agent节点的输出数据\nconst aiOutput = $input.first().json;\n\n// 提取并清理markdown内容\nlet markdownContent = aiOutput.output;\nif (markdownContent.includes('```markdown')) {\n  markdownContent = markdownContent.replace(/```markdown\\s*/, '').replace(/\\\\s*```$/, '');\n}\n\n// ============ 核心优化：钉钉/企业微信 Markdown 兼容+排版美化处理 开始 ============\nmarkdownContent = markdownContent\n  // 1. 钉钉不支持一级标题，# 替换为 ## ，二级标题###保留\n  .replace(/^# /gm, '## ')\n  // 2. 去掉钉钉不兼容的>引用块，替换为加粗标题\n  .replace(/> \\*\\*总结\\*\\*：/g, '### 总结：')\n  // 3. 把所有 *   开头的列表，统一改为 - 开头（钉钉对 - 列表支持最好）\n  .replace(/\\n\\*   /g, '\\n- ')\n  // 4. 给每个产品信息后加空行，解决拥挤问题\n  .replace(/。\\n/g, '。\\n\\n')\n  // 5. 替换中文双引号为英文双引号，避免钉钉显示乱码\n  .replace(/“/g, '\"').replace(/”/g, '\"')\n  // 6. 增加合理的行间距，让内容不拥挤\n  .replace(/\\n\\n+/g, '\\n\\n');\n// ============ 核心优化 结束 ============\n\n// 构建钉钉/企业微信「群聊机器人」所需的JSON格式\nconst botMessage = {\n  \"msgtype\": \"markdown\",\n  \"markdown\": {\n    \"content\": markdownContent\n  }\n};\n\n// 输出给HTTP Request节点\nreturn botMessage;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2240,
        640
      ],
      "id": "7e220e96-8d61-410d-9b6e-16926e8e171a",
      "name": "covert msg to markdown"
    },
    {
      "parameters": {
        "language": "python",
        "pythonCode": "import time\nimport hmac\nimport hashlib\nimport base64\nimport urllib.parse\n\n\nfor item in _input.all():\n  timestamp = str(round(time.time() * 1000))\n  secret = 'SECcf5a5f6c6a66e10532471b138ef24e8322f6cf16ae50a3669aa27c3cb4471c46'\n  secret_enc = secret.encode('utf-8')\n  string_to_sign = '{}\\n{}'.format(timestamp, secret)\n  string_to_sign_enc = string_to_sign.encode('utf-8')\n  hmac_code = hmac.new(secret_enc, string_to_sign_enc, digestmod=hashlib.sha256).digest()\n  sign = urllib.parse.quote_plus(base64.b64encode(hmac_code))\n  item.json.timestamp = timestamp\n  item.json.sign = sign \nreturn _input.all()"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2464,
        640
      ],
      "id": "1344f159-1446-4031-b947-4f7a5c691b6d",
      "name": "sign dingding data"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://qyapi.weixin.qq.com/cgi-bin/webhook/send",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "key",
              "value": "a5450767-ad81-4dd6-b0a2-fa3074ea4811"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n    \"msgtype\": \"markdown\",\n    \"markdown\": {\n        \"content\": {{ $json.markdown.content.toJsonString() }}\n    }\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        2240,
        464
      ],
      "id": "1368baf0-b8cb-414c-a60e-9873f500f4c7",
      "name": "Send msg to wechat"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "=https://oapi.dingtalk.com/robot/send?access_token=31215f5d1c8320f58a8cc367bcda71f9c2610b7fbd2708b8b9307fdb7b845fda",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "timestamp",
              "value": "={{ $json.timestamp }}"
            },
            {
              "name": "=sign",
              "value": "={{ $json.sign }}"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n     \"msgtype\": \"markdown\",\n     \"markdown\": {\n         \"title\":\"智能AI推送\",\n         \"text\": {{ $json.markdown.content.toJsonString() }}\n    },\n      \"at\": {\n          \"atMobiles\": [],\n          \"atUserIds\": [],\n          \"isAtAll\": true\n      }\n }",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        2720,
        640
      ],
      "id": "62744bc7-4e22-463c-af79-d084b4c18cb4",
      "name": "Send msg to dingding"
    },
    {
      "parameters": {
        "jsCode": "// ===================== N8N 万能数据统计计算器 - 完美兼容【数量/总数量】终极版 =====================\n// ✅ 核心修复：完美兼容「数量」「总数量」双字段，优先级置顶，彻底解决匹配问题\n// ✅ 完美适配所有场景：产量统计/双月对比/库房库存/出入库流水/保质期查询/重量统一按数量统计\n// ✅ 核心特性：自动过滤0库存+数值兜底防NaN+多维度分组统计+精准保留2位小数+无任何报错\nconst rawData = $input.all().map(item => item.json);\nconst validData = rawData.filter(item => item && Object.keys(item).length > 0 && JSON.stringify(item) !== '{}');\n\nconst getFieldType = (value) => {\n  if (value === null || value === undefined || value === '' || typeof value === 'boolean') return 'empty';\n  const valStr = String(value).trim();\n  const isMonthFormat = /^\\d{4}-\\d{2}$/.test(valStr);\n  const isDateFormat = /^\\d{4}-\\d{2}-\\d{2}$/.test(valStr);\n  if (isMonthFormat || isDateFormat) return 'text';\n  const numVal = parseFloat(valStr);\n  return !isNaN(numVal) ? 'number' : 'text';\n};\n\nconst allFields = validData.length > 0 ? Object.keys(validData[0]) : [];\nconst textFields = allFields.filter(field => getFieldType(validData[0][field]) === 'text');\nconst numberFields = allFields.filter(field => getFieldType(validData[0][field]) === 'number');\n\nconst hasUnitField = textFields.includes('单位') || textFields.includes('数量单位');\nconst unitKey = textFields.includes('数量单位') ? '数量单位' : '单位';\n\nconst hasProduct = textFields.includes('产品名称');\nconst hasWarehouse = textFields.includes('库房名称');\nconst hasCurrStock = numberFields.includes('当前数量');\nconst hasInOutStock = numberFields.includes('总入库数量') || numberFields.includes('总出库数量');\nconst hasExpStatus = textFields.includes('保质期状态');\nconst hasInOutDir = textFields.includes('出入库方向');\n// ✅ 核心修改1：同时兼容「总数量」「数量」，优先级置顶，产量/重量全部按数量统计\nconst hasMonthTotal = numberFields.includes('总数量') || numberFields.includes('数量');\nconst hasRecordCount = numberFields.includes('产品记录数');\nconst hasStatMonth = textFields.includes('统计月份');\n\n// ✅ 核心修改2：优先级排序 总数量 > 数量 > 当前数量 > 总入库数量 完美兼容所有数值字段\nconst countField = numberFields.includes('总数量') ? '总数量' : \n                  numberFields.includes('数量') ? '数量' : \n                  numberFields.includes('当前数量') ? '当前数量' : \n                  numberFields.includes('总入库数量') ? '总入库数量' : '数量';\n\nlet calcResult = {};\n\nif (hasProduct && hasWarehouse && hasUnitField && hasMonthTotal && hasInOutDir && hasStatMonth && !hasCurrStock && !hasInOutStock) {\n  const filterValidData = validData.filter(item => {\n    const totalNum = parseFloat(item[countField]) || 0;\n    const inOutDir = item['出入库方向'];\n    const statMonth = item['统计月份'];\n    return totalNum > 0 && inOutDir && ['入库','出库'].includes(inOutDir) && statMonth && /^\\d{4}-\\d{2}$/.test(statMonth);\n  });\n\n  const allStatMonths = [...new Set(filterValidData.map(item => item['统计月份']))].sort((a,b) => b.localeCompare(a));\n  const isCompareMode = allStatMonths.length >= 2;\n  const mainMonth = allStatMonths[0];\n  const prevMonth = allStatMonths[1] || '';\n\n  const inStockData = filterValidData.filter(item => item['出入库方向'] === '入库');\n  const outStockData = filterValidData.filter(item => item['出入库方向'] === '出库');\n\n  const productGroup = {};\n  filterValidData.forEach(item => {\n    const product = item['产品名称'];\n    if (!productGroup[product]) productGroup[product] = [];\n    productGroup[product].push(item);\n  });\n\n  const warehouseGroup = {};\n  filterValidData.forEach(item => {\n    const warehouse = item['库房名称'];\n    if (!warehouseGroup[warehouse]) warehouseGroup[warehouse] = [];\n    warehouseGroup[warehouse].push(item);\n  });\n\n  const getGlobalSummary = () => {\n    if(!isCompareMode){\n      const inTotal = parseFloat(inStockData.reduce((sum, item) => sum + (parseFloat(item[countField]) || 0), 0).toFixed(2));\n      const outTotal = parseFloat(outStockData.reduce((sum, item) => sum + (parseFloat(item[countField]) || 0), 0).toFixed(2));\n      return {\n        统计月份: mainMonth,\n        本月产品入库总数量: inTotal,\n        本月产品出库总数量: outTotal,\n        入库产品记录总条数: inStockData.length,\n        出库产品记录总条数: outStockData.length,\n        涉及产品总种类数: Object.keys(productGroup).length,\n        涉及库房总数量: Object.keys(warehouseGroup).length\n      };\n    }else{\n      const currInData = inStockData.filter(item => item['统计月份'] === mainMonth);\n      const currOutData = outStockData.filter(item => item['统计月份'] === mainMonth);\n      const prevInData = inStockData.filter(item => item['统计月份'] === prevMonth);\n      const prevOutData = outStockData.filter(item => item['统计月份'] === prevMonth);\n\n      const currInTotal = parseFloat(currInData.reduce((sum, item) => sum + (parseFloat(item[countField]) || 0), 0).toFixed(2));\n      const currOutTotal = parseFloat(currOutData.reduce((sum, item) => sum + (parseFloat(item[countField]) || 0), 0).toFixed(2));\n      const prevInTotal = parseFloat(prevInData.reduce((sum, item) => sum + (parseFloat(item[countField]) || 0), 0).toFixed(2));\n      const prevOutTotal = parseFloat(prevOutData.reduce((sum, item) => sum + (parseFloat(item[countField]) || 0), 0).toFixed(2));\n\n      const inDiff = parseFloat((currInTotal - prevInTotal).toFixed(2));\n      const outDiff = parseFloat((currOutTotal - prevOutTotal).toFixed(2));\n      const inRate = prevInTotal === 0 ? 0 : parseFloat(((inDiff / prevInTotal) * 100).toFixed(2));\n      const outRate = prevOutTotal === 0 ? 0 : parseFloat(((outDiff / prevOutTotal) * 100).toFixed(2));\n\n      return {\n        对比维度: `${mainMonth}(本月) VS ${prevMonth}(上月)`,\n        本月入库总数量: currInTotal,\n        本月出库总数量: currOutTotal,\n        上月入库总数量: prevInTotal,\n        上月出库总数量: prevOutTotal,\n        入库数量增减量: inDiff,\n        入库增长率: `${inRate}%`,\n        出库数量增减量: outDiff,\n        出库增长率: `${outRate}%`,\n        涉及产品总种类数: Object.keys(productGroup).length,\n        涉及库房总数量: Object.keys(warehouseGroup).length\n      };\n    }\n  };\n\n  const getProductGroup = () => {\n    const result = {};\n    Object.keys(productGroup).forEach(product => {\n      const productData = productGroup[product];\n      const prodType = productData[0]['产品类型'] || '未知类型';\n      const unit = productData[0][unitKey] || '未知单位';\n      if(!isCompareMode){\n        const inData = productData.filter(item => item['出入库方向'] === '入库');\n        const outData = productData.filter(item => item['出入库方向'] === '出库');\n        const inTotal = parseFloat(inData.reduce((sum, item) => sum + (parseFloat(item[countField]) || 0), 0).toFixed(2));\n        const outTotal = parseFloat(outData.reduce((sum, item) => sum + (parseFloat(item[countField]) || 0), 0).toFixed(2));\n        result[product] = {\n          产品名称: product,\n          产品类型: prodType,\n          数量单位: unit,\n          统计月份: mainMonth,\n          入库总数量: inTotal,\n          出库总数量: outTotal,\n          涉及库房: [...new Set(productData.map(item => item['库房名称']))],\n          明细数据: productData\n        };\n      }else{\n        const currIn = parseFloat(productData.filter(item => item['统计月份']===mainMonth && item['出入库方向']==='入库').reduce((sum,item)=>sum+(parseFloat(item[countField])||0),0).toFixed(2));\n        const currOut = parseFloat(productData.filter(item => item['统计月份']===mainMonth && item['出入库方向']==='出库').reduce((sum,item)=>sum+(parseFloat(item[countField])||0),0).toFixed(2));\n        const prevIn = parseFloat(productData.filter(item => item['统计月份']===prevMonth && item['出入库方向']==='入库').reduce((sum,item)=>sum+(parseFloat(item[countField])||0),0).toFixed(2));\n        const prevOut = parseFloat(productData.filter(item => item['统计月份']===prevMonth && item['出入库方向']==='出库').reduce((sum,item)=>sum+(parseFloat(item[countField])||0),0).toFixed(2));\n        const inDiff = parseFloat((currIn - prevIn).toFixed(2));\n        const outDiff = parseFloat((currOut - prevOut).toFixed(2));\n        const inRate = prevIn ===0 ? 0 : parseFloat(((inDiff/prevIn)*100).toFixed(2));\n        const outRate = prevOut ===0 ? 0 : parseFloat(((outDiff/prevOut)*100).toFixed(2));\n        result[product] = {\n          产品名称: product,\n          产品类型: prodType,\n          数量单位: unit,\n          本月入库数量: currIn,\n          本月出库数量: currOut,\n          上月入库数量: prevIn,\n          上月出库数量: prevOut,\n          入库增减量: inDiff,\n          入库增长率: `${inRate}%`,\n          出库增减量: outDiff,\n          出库增长率: `${outRate}%`,\n          涉及库房: [...new Set(productData.map(item => item['库房名称']))],\n          明细数据: productData\n        };\n      }\n    });\n    return Object.values(result).sort((a,b) => (b.本月入库数量 || b.入库总数量) - (a.本月入库数量 || a.入库总数量));\n  };\n\n  const getWarehouseGroup = () => {\n    const result = {};\n    Object.keys(warehouseGroup).forEach(warehouse => {\n      const wareData = warehouseGroup[warehouse];\n      if(!isCompareMode){\n        const inTotal = parseFloat(wareData.filter(item => item['出入库方向']==='入库').reduce((sum,item)=>sum+(parseFloat(item[countField])||0),0).toFixed(2));\n        const outTotal = parseFloat(wareData.filter(item => item['出入库方向']==='出库').reduce((sum,item)=>sum+(parseFloat(item[countField])||0),0).toFixed(2));\n        result[warehouse] = {\n          库房名称: warehouse,\n          统计月份: mainMonth,\n          入库总数量: inTotal,\n          出库总数量: outTotal,\n          产品种类数: [...new Set(wareData.map(item => item['产品名称']))].length,\n          明细数据: wareData\n        };\n      }else{\n        const currIn = parseFloat(wareData.filter(item => item['统计月份']===mainMonth && item['出入库方向']==='入库').reduce((sum,item)=>sum+(parseFloat(item[countField])||0),0).toFixed(2));\n        const currOut = parseFloat(wareData.filter(item => item['统计月份']===mainMonth && item['出入库方向']==='出库').reduce((sum,item)=>sum+(parseFloat(item[countField])||0),0).toFixed(2));\n        const prevIn = parseFloat(wareData.filter(item => item['统计月份']===prevMonth && item['出入库方向']==='入库').reduce((sum,item)=>sum+(parseFloat(item[countField])||0),0).toFixed(2));\n        const prevOut = parseFloat(wareData.filter(item => item['统计月份']===prevMonth && item['出入库方向']==='出库').reduce((sum,item)=>sum+(parseFloat(item[countField])||0),0).toFixed(2));\n        result[warehouse] = {\n          库房名称: warehouse,\n          本月入库数量: currIn,\n          本月出库数量: currOut,\n          上月入库数量: prevIn,\n          上月出库数量: prevOut,\n          入库增减量: parseFloat((currIn - prevIn).toFixed(2)),\n          出库增减量: parseFloat((currOut - prevOut).toFixed(2)),\n          产品种类数: [...new Set(wareData.map(item => item['产品名称']))].length,\n          明细数据: wareData\n        };\n      }\n    });\n    return Object.values(result).sort((a,b) => (b.本月入库数量 || b.入库总数量) - (a.本月入库数量 || a.入库总数量));\n  };\n\n  calcResult = {\n    baseInfo: {\n      dataType: isCompareMode ? \"产量对比统计【本月VS上月 | 严格区分入库出库】\" : \"单月产量统计【严格区分入库出库】\",\n      dataRowCount: validData.length,\n      validDataRow: filterValidData.length,\n      statisticMode: isCompareMode ? \"双月对比模式\" : \"单月统计模式\",\n      dimensionFields: textFields,\n      statisticFields: numberFields\n    },\n    globalSummary: getGlobalSummary(),\n    groupByProduct: getProductGroup(),\n    groupByWarehouse: getWarehouseGroup(),\n    validDetailData: filterValidData,\n    inStockDetail: inStockData,\n    outStockDetail: outStockData\n  };\n\n// ✅ ✅ ✅ 核心修复区域：库房实时库存静态数据 - 彻底解决执行时机问题，无任何报错 ✅ ✅ ✅\n} else if (hasProduct && hasWarehouse && hasCurrStock && hasUnitField && !hasInOutStock && !hasExpStatus) {\n  const filterValidData = validData.filter(item => item[countField] !== null && item[countField] !== undefined && parseFloat(item[countField]) > 0);\n  const unitGroup = {};\n  filterValidData.forEach(item => {\n    const unit = item[unitKey];\n    if (!unitGroup[unit]) unitGroup[unit] = [];\n    unitGroup[unit].push(item);\n  });\n\n  calcResult = {\n    baseInfo: {\n      dataType: \"库房实时库存静态数据【核心业务】\",\n      dataRowCount: validData.length,\n      validStockRow: filterValidData.length,\n      dimensionFields: textFields,\n      statisticFields: numberFields,\n      unitField: unitKey,\n      countField: countField,\n      isEmpty: filterValidData.length === 0\n    },\n    globalStockTotal: {\n      总有效库存产品数: filterValidData.length,\n      涉及库房总数: [...new Set(filterValidData.map(item => item['库房名称']))].length,\n      涉及产品总种类数: [...new Set(filterValidData.map(item => item['产品名称']))].length,\n      涉及计量单位数: Object.keys(unitGroup).length,\n      各单位库存汇总: {}\n    },\n    groupByUnit: {},\n    validDetailData: filterValidData\n  };\n\n  const unitResult = {};\n  const unitSummary = {};\n  Object.keys(unitGroup).forEach(unit => {\n    const unitData = unitGroup[unit];\n    const totalQty = unitData.reduce((sum, item) => sum + (parseFloat(item[countField]) || 0), 0).toFixed(2)*1;\n    unitResult[unit] = {\n      计量单位: unit,\n      该单位产品数: unitData.length,\n      该单位库存总量: totalQty,\n      groupByWarehouse: (() => {\n        const warehouseGroup = {};\n        unitData.forEach(item => {\n          const warehouse = item['库房名称'];\n          if (!warehouseGroup[warehouse]) warehouseGroup[warehouse] = {库房名称: warehouse,库存总量:0,产品明细:[]};\n          warehouseGroup[warehouse].库存总量 += (parseFloat(item[countField]) || 0);\n          warehouseGroup[warehouse].产品明细.push(item);\n        });\n        return Object.values(warehouseGroup).sort((a,b)=>b.库存总量 - a.库存总量);\n      })(),\n      groupByProduct: (() => {\n        const productGroup = {};\n        unitData.forEach(item => {\n          const product = item['产品名称'];\n          if (!productGroup[product]) productGroup[product] = {产品名称: product,库存总量:0,涉及库房:[],存放位置:[]};\n          productGroup[product].库存总量 += (parseFloat(item[countField]) || 0);\n          if(!productGroup[product].涉及库房.includes(item['库房名称'])) productGroup[product].涉及库房.push(item['库房名称']);\n          if(item['存放位置'] && !productGroup[product].存放位置.includes(item['存放位置'])) productGroup[product].存放位置.push(item['存放位置']);\n        });\n        return Object.values(productGroup).sort((a,b)=>b.库存总量 - a.库存总量);\n      })(),\n      detailData: unitData\n    };\n    unitSummary[unit] = totalQty;\n  });\n\n  calcResult.groupByUnit = unitResult;\n  calcResult.globalStockTotal.各单位库存汇总 = unitSummary;\n\n} else if (hasExpStatus && hasProduct && hasCurrStock && hasUnitField) {\n  const filterValidData = validData.filter(item => item[countField] !== null && item[countField] !== undefined && parseFloat(item[countField]) > 0);\n  calcResult = {\n    baseInfo: {\n      dataType: \"库存产品保质期明细数据\",\n      dataRowCount: validData.length,\n      validCountRow: filterValidData.length,\n      dimensionFields: textFields,\n      statisticFields: numberFields,\n      countField: countField,\n      unitField: unitKey,\n      isEmpty: filterValidData.length === 0\n    },\n    groupByExpStatus: (() => {\n      const statusGroup = {};\n      filterValidData.forEach(item => {\n        const expStatus = item['保质期状态'];\n        if (!statusGroup[expStatus]) statusGroup[expStatus] = [];\n        statusGroup[expStatus].push(item);\n      });\n      Object.keys(statusGroup).forEach(status => {\n        const statusData = statusGroup[status];\n        const statusResult = {\n          保质期状态: status,\n          数据条数: statusData.length,\n          该状态总数量: statusData.reduce((sum, item) => sum + (parseFloat(item[countField]) || 0), 0).toFixed(2)*1,\n          单位: statusData[0][unitKey],\n          groupByProduct: [],\n          groupByWarehouse: [],\n          detailList: statusData\n        };\n        if (hasProduct) {\n          const productGroup = {};\n          statusData.forEach(item => {\n            const productName = item['产品名称'];\n            if (!productGroup[productName]) {\n              productGroup[productName] = {产品名称: productName,单位: item[unitKey],总数量:0};\n            }\n            productGroup[productName].总数量 += (parseFloat(item[countField]) || 0);\n          });\n          statusResult.groupByProduct = Object.values(productGroup).filter(p => p.总数量>0).sort((a,b)=>b.总数量-a.总数量);\n        }\n        if (hasWarehouse) {\n          const warehouseGroup = {};\n          statusData.forEach(item => {\n            const warehouseName = item['库房名称'] || '无库房';\n            if (!warehouseGroup[warehouseName]) warehouseGroup[warehouseName] = {库房名称: warehouseName,单位: item[unitKey],总数量:0};\n            warehouseGroup[warehouseName].总数量 += (parseFloat(item[countField]) || 0);\n          });\n          statusResult.groupByWarehouse = Object.values(warehouseGroup).filter(w => w.总数量>0).sort((a,b)=>b.总数量-a.总数量);\n        }\n        statusGroup[status] = statusResult;\n      });\n      return statusGroup;\n    })(),\n    totalSummary: {\n      库存产品总数量: filterValidData.reduce((sum, item) => sum + (parseFloat(item[countField]) || 0), 0).toFixed(2)*1,\n      已过期产品总数量: filterValidData.filter(item=>item['保质期状态']==='已过期').reduce((sum,item)=>sum+(parseFloat(item[countField])||0),0).toFixed(2)*1,\n      正常保质期产品总数量: filterValidData.filter(item=>item['保质期状态']==='正常').reduce((sum,item)=>sum+(parseFloat(item[countField])||0),0).toFixed(2)*1,\n      已过期产品占比: filterValidData.length>0 ? `${((filterValidData.filter(item=>item['保质期状态']==='已过期').reduce((sum,item)=>sum+(parseFloat(item[countField])||0),0)/filterValidData.reduce((sum,item)=>sum+(parseFloat(item[countField])||0),0))*100).toFixed(2)}%` : '0%'\n    }\n  };\n\n} else if (hasProduct && hasInOutStock && (hasWarehouse || hasInOutDir)) {\n  const filterValidData = validData.filter(item => {\n    const inNum = parseFloat(item['总入库数量'] || 0);\n    const outNum = parseFloat(item['总出库数量'] || 0);\n    return inNum + outNum > 0;\n  });\n  calcResult = {\n    baseInfo: {\n      dataType: \"库存出入库明细数据【无单位】\",\n      dataRowCount: validData.length,\n      validCountRow: filterValidData.length,\n      dimensionFields: textFields,\n      statisticFields: numberFields,\n      isEmpty: filterValidData.length === 0\n    },\n    globalTotal: {\n      全库房总入库数量: filterValidData.reduce((sum, item) => sum + (parseFloat(item['总入库数量']) || 0), 0).toFixed(2)*1,\n      全库房总出库数量: filterValidData.reduce((sum, item) => sum + (parseFloat(item['总出库数量']) || 0), 0).toFixed(2)*1,\n      总入库记录数: filterValidData.reduce((sum, item) => sum + parseInt(item['入库记录数'] || 0), 0),\n      总出库记录数: filterValidData.reduce((sum, item) => sum + parseInt(item['出库记录数'] || 0), 0),\n      有效产品总数: filterValidData.length,\n      涉及库房数: [...new Set(filterValidData.map(item => item['库房名称']))].length,\n      涉及产品种类数: [...new Set(filterValidData.map(item => item['产品名称']))].length\n    },\n    groupByProduct: (() => {\n      const productGroup = {};\n      filterValidData.forEach(item => {\n        const productName = item['产品名称'];\n        if (!productGroup[productName]) {\n          productGroup[productName] = {\n            产品名称: productName,\n            合并总入库数量: 0,\n            合并总出库数量: 0,\n            合并入库记录数:0,\n            合并出库记录数:0,\n            涉及库房: [],\n            库房明细: []\n          };\n        }\n        productGroup[productName].合并总入库数量 += (parseFloat(item['总入库数量']) || 0);\n        productGroup[productName].合并总出库数量 += (parseFloat(item['总出库数量']) || 0);\n        productGroup[productName].合并入库记录数 += parseInt(item['入库记录数'] ||0);\n        productGroup[productName].合并出库记录数 += parseInt(item['出库记录数'] ||0);\n        if(!productGroup[productName].涉及库房.includes(item['库房名称'])) productGroup[productName].涉及库房.push(item['库房名称']);\n        productGroup[productName].库房明细.push({库房名称: item['库房名称'],入库数量: item['总入库数量'],出库数量: item['总出库数量']});\n      });\n      return Object.values(productGroup).sort((a,b) => b.合并总入库数量 - a.合并总入库数量);\n    })(),\n    groupByWarehouse: (() => {\n      const warehouseGroup = {};\n      filterValidData.forEach(item => {\n        const warehouseName = item['库房名称'];\n        if (!warehouseGroup[warehouseName]) {\n          warehouseGroup[warehouseName] = {库房名称: warehouseName,库房总入库:0,库房总出库:0,产品明细:[]};\n        }\n        warehouseGroup[warehouseName].库房总入库 += (parseFloat(item['总入库数量']) ||0);\n        warehouseGroup[warehouseName].库房总出库 += (parseFloat(item['总出库数量']) ||0);\n        warehouseGroup[warehouseName].产品明细.push(item);\n      });\n      return Object.values(warehouseGroup).sort((a,b) => b.库房总入库 - a.库房总入库);\n    })(),\n    detailData: filterValidData\n  };\n\n} else {\n  calcResult = {\n    baseInfo: {\n      dataType: \"统计汇总数据(月度/年度/环比等)\",\n      dataRowCount: validData.length,\n      dimensionFields: textFields,\n      statisticFields: numberFields,\n      isEmpty: validData.length === 0\n    },\n    statisticData: validData.map(item => {\n      const formatItem = {};\n      allFields.forEach(field => {\n        const fieldVal = item[field];\n        const type = getFieldType(fieldVal);\n        formatItem[field] = type === 'number' ? (parseFloat(fieldVal) || 0) : (fieldVal || '');\n      });\n      return formatItem;\n    })\n  };\n}\n\nif (calcResult.baseInfo?.isEmpty && validData.length === 0) {\n  calcResult = {isEmpty: true, msg: '未找到相关数据'};\n}\n\nreturn calcResult;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1520,
        640
      ],
      "id": "432e8c4a-c7b7-41bb-b232-2f2ff9b8df3c",
      "name": "万能数据统计计算器"
    },
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "ding_talk",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2.1,
      "position": [
        -224,
        640
      ],
      "id": "edc907de-44dc-40b6-af65-d92209b766f6",
      "name": "Webhook",
      "webhookId": "184d0b3d-ee10-44a9-8286-949f60d80467"
    }
  ],
  "pinData": {},
  "connections": {
    "get msg from dingtalk": {
      "main": [
        [
          {
            "node": "Load the schema from the local file",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Window Buffer Memory": {
      "ai_memory": [
        [
          {
            "node": "natural language to sql",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "Add table name to output": {
      "main": [
        [
          {
            "node": "Convert data to Json",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract data from file": {
      "main": [
        [
          {
            "node": "Combine schema data and chat input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When clicking \"Test workflow\"": {
      "main": [
        [
          {
            "node": "query tables name",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combine schema data and chat input": {
      "main": [
        [
          {
            "node": "natural language to sql",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Load the schema from the local file": {
      "main": [
        [
          {
            "node": "Extract data from file",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Convert data to Json": {
      "main": [
        [
          {
            "node": "Save file locally",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "query table column": {
      "main": [
        [
          {
            "node": "Add table name to output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "query tables name": {
      "main": [
        [
          {
            "node": "query table column",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DeepSeek Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "natural language to sql",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "natural language to sql": {
      "main": [
        [
          {
            "node": "sql query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "sql query": {
      "main": [
        [
          {
            "node": "万能数据统计计算器",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "sql to natural language": {
      "main": [
        [
          {
            "node": "covert msg to markdown",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "自然语言chat": {
      "ai_languageModel": [
        [
          {
            "node": "sql to natural language",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "covert msg to markdown": {
      "main": [
        [
          {
            "node": "sign dingding data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "sign dingding data": {
      "main": [
        [
          {
            "node": "Send msg to dingding",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "万能数据统计计算器": {
      "main": [
        [
          {
            "node": "sql to natural language",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Webhook": {
      "main": [
        [
          {
            "node": "get msg from dingtalk",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "defac181-8c7b-40b5-adf7-60e15547f46f",
  "meta": {
    "instanceId": "a2273711b4aea9d7d7574d8030e43adacae126bfdd44e135f1c866833d5f0aba"
  },
  "id": "nqP0bGpcGH6C0GmA",
  "tags": []
}